# 2. 유닉스 시스템 프로그래밍 파일 입출력
* 파일은 관련있는 데이터의 집합
* 유닉스에서 파일은 **일반파일**과 **특수파일**로 구분된다
	* 일반파일: 텍스트 바이너리 형태의 데이터를 저장하는 파일
	* 특수파일: 데이터 전송, 장치 접근에 사용하는 파일
* 유닉스에서 파일을 읽고 쓰는 방법은 **저수준 파일 입출력**과 **고수준 파일 입출력**으로 구분
	* 저수준 파일 입출력: 유닉스 커널의 시스템 호출을 사용하여 파일 입출력을 수행
	* 고수준 파일 입출력: 유닉스 커널의 시스템 호출을 사용하여 파일 입출력을 수행

|             | 저수준 파일 입출력                                                                                               |                                                          고수준 파일 입출력                                                          |
|:-----------:|------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------:|
|             |                                                                                                                  |                                                                                                                                      |
| 파일 지시자 | int fd (파일 지시자, file descriptor)                                                                            |                                                        FILE *fp; (파일 포인터)                                                       |
|     특징    | 1. 유닉스 커널의 시스템 호출 사용 (빠르게 접근)   2. 바이트 단위의 읽고 쓰기   3. 특수 파일에 대한 접근이 가능   | 1. C언어의 표준함수로 제공(사용하기 쉽다)   2. 버퍼 단위의 읽고 쓰기   3. 데이터의 입출력 동기화가 쉽다  4. 여러 가지 형식을 지원   |
|   주요함수  | open, close, read, write, dup, dup2, fcntl, lseek, fsync                                                         |                              fopen, fclose, fread, fwrite, fputs, fgets, fprintf, fscanf, freopen, fseek                             |


> <파일 기술자와 파일 포인터 간의 변환>  
> fdopen: 파일 기술자로부터 파일 포인터를 생성하는데 사용  
> fileno: 파일 포인터로부터 파일 기술자 정보를 추출  

- - - -

## 저수준 파일 입출력
* 바이트 단위로 입출력 수행
* 일반 파일, 특수 파일 모두 읽고 쓰기 가능

### 파일 기술자 (file descriptor)
* 현재 열려있는 파일을 구분할 목적으로 유닉스가 붙여놓은 번호
* 저수준 파일 입출력에서 열린 파일을 참조하는 데 사용하는 지시자 역할을 한다

* 프로세스가 처음 동작할 때 세 파일 기술자는 번호가 자동으로 할당됨
	* 0번: 표준 입력 (키보드)
	* 1번: 표준 출력 (모니터)
	* 2번: 표준 오류 출력 (모니터)
* 이후 open 함수를 사용해 파일을 열었을때 부여됨 (작은 숫자부터 할당)

* 한 프로세스가 동시에 열 수 있는 파일의 갯수에는 제한이 있다(기본 256개) (변경하려면 유닉스 커널의 설정을 변경하고 재부팅해야함)


### 파일 열기
* 파일의 내용을 읽거나 쓸 수 있는 상태로 변경하는 일
* 성공하면 파일 기술자를 리턴, 실패하면 -1을 리턴하고 외부 변수 errno에 오류 코드를 저장
#### open(2)
``` c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *path, int oflag [, mode_t mode]);

// path: 열려는 파일이 있는 경로
// oflag: 파일 상태 플래그
// mode: 접근 권한
```
* path에 지정한 파일을 oflag에 지정한 상태 플래그의 값에 따라 열고 파일 기술자를 반환

* oflag (<sys/fcntl.h> 파일에 정의되어 있음)
	*  O_RDONLY: 읽기 전용으로 열기
	* O_WRONLY: 쓰기 전용으로 열기
	* O_RDWR: 읽기/쓰기용으로 열기
	* O_CREAT: 파일이 없으면 생성, 있으면 아무일도 없음
	* O_EXCL: O_CREATE 옵션과 함께 사용할 경우 기존에 없는 파일이면 생성, 있으면 오류메시지 출력
	* O_APPEND: 파일의 맨 끝에 내용을 추가
	* O_TRUNC: 파일을 생성할때 이미 있으면 쓰기 옵션으로 열었으면 내용을 지우고 파일의 길이를 0으로 변경
	* O_NONBLOCK / O_NDELAY: 비블로킹 입출력 옵션, 파일을 읽거나 쓴 뒤의 동작에 영향(FIFO 같은 특수 파일의 입출력에 의미가 있다)
	* O_SYNC / O_DSYNC: 저장 장치에 쓰기를 마쳐야 쓰기 동작을 완료. O_SYNC는 파일의 수정 시각 속성도 수정할 때까지 기다림(실행 속도는 느려질 수 있지만 디스크에 확실하게 저장됨을 보장)
* 플래그를 or 연산자로 연결해 지정 가능

* mode
	* 파일의 접근 권한을 설정하는 것(파일을 생성할 때만 사용)
	* <sys/stat.h> 파일에 플래그가 정의 되어있음


### 파일 생성
#### create(2)
``` c
#include <sys/stat.h>
#include <fcntl.h>

int create(const char *path, mode_t mode);

// path: 파일을 생성할 경로
// mode: 접근 권한
```
* open함수가 없는 구버전 유닉스에서 사용하던 것
* create로 파일을 생성하면 파일 기술자가 리턴되므로 별도로 open함수를 호출해 열 필요가 없다


### 파일 닫기
* 파일을 닫아야 파일의 내용을 하드 디스크에 온전히 기록하고 파일이 사용한 버퍼 등을 반납할 수 있다
#### close(2)
``` c
#include <unistd.h>

int close(int fildes);

// fildes: 파일 기술자
```

* 파일 입출력 작업을 모두 완료하면 반드시 파일을 닫아야함 (프로세스 당 열수있는 파일의 갯수에 제한이 있다)
* 성공하면 0을 리턴, 실패하면 -1을 리턴하고 오류코드를 외부변수 errno에 저장


### 파일 읽기
#### read(2)
``` c
#include <unistd.h>

ssize_t read(int fildes, void *buf, size_t nbytes);

// fildes: 파일 기술자
// buf: 바이트를 저장할 메모리 영역의 시작 주소
// nbytes: 읽어올 바이트 수
```
* 성공하면 실제 읽어온 바이트 수를 리턴, 실패하면 -1을 리턴
* 만약 리턴값이 0이라면 파일의 끝에 도달한 것
* 파일을 열면 읽어올 위치를 나타내는 오프셋이 파일의 시작을 가리키지만, read함수를 실행할 때마다 읽어온 크기만큼 오프셋이 이동해 다음 읽어올 위치를 가리킴

### 파일 쓰기
#### write(2)
``` c
#include <unistd.h>

ssize_t write(int fildes, const void *buf, size_t nbytes);

// fildes: 파일 기술자
// buf: 파일에 기록할 데이터를 저장한 메모리 영역
// nbytes: buf의 크기(기록할 데이터의 크기)
```
* 성공하면 실제 쓰기를 수행한 바이트 수를 리턴, 오류가 발생하면 -1을 리턴

### 파일 오프셋(file offset) 지정
* 파일의 내용을 읽거나 쓰면 현재 읽을 위치나 쓸 위치를 알려주는 오프셋이 자동으로 변경된다
* 오프셋은 파일의 시작 지점에서 현재 위치까지의 바이트 수
* 파일을 열었을때는 0이고, read/write 함수를 실행 할 때마다 이동한 만큼 오프셋이 변경된다
* **한 파일에서 오프셋은 하나** (읽기, 쓰기 별로 오프셋이 따로 있는 것이 아님)

#### lseek(2) - 파일 오프셋 위치 지정
``` c
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fildes, off_t offset, int whence);

// fildes: 파일 기술자
// offset: 이동할 오프셋의 위치
// whence: 오프셋의 기준 위치
```

* 파일 기술자가 가리키는 파일에서 offset으로 지정한 크기만큼 오프셋을 이동시킨다
* 이때 offset의 값은 whence의 값을 기준으로 한다
* whence 값의 종류
	* SEEK_SET: 파일의 시작을 기준
	* SEEK_CUR: 현재 위치를 기준
	* SEEK_END: 파일의 끝을 기준

* 오프셋 이동이 성공하면 새로운 오프셋을 리턴하고, 실패하면 -1을 리턴한다 (리턴값의 데이터형 off_t는 long으로 정의 되어있음)


### 파일 기술자 복사
* 파일을 열때 파일 기술자가 할당되는데 이 파일 기술자를 복사해 같은 파일을 가리키는 두번째 파일 기술자를 생성할 수 있다

#### dup(2) - 파일 기술자 복사
``` c
#include <unistd.h>

int dup(int fildes);

// fildes: 파일기술자
```
* 기존 파일 기술자를 인자로 받아서 새로운 파일 기술자를 리턴한다
	* 이때 리턴되는 파일 기술자는 현재 할당할 수 있는 파일 기술자 중 가장 작은 값으로 자동 할당된다
* 입출력 방향 전환에서 많이 사용


#### dup2(2) - 파일 기술자 복사
``` c
#include <unistd.h>

int dup2(int fildes, int fildes2);

// fildes: 파일기술자
// fildes2: 파일기술자를 복사할 곳
```
* dup은 새로운 파일 기술자를 자동으로 할당하지만 dup2는 새로운 파일 기술자를 지정할 수 있게 해준다

### 파일 기술자 제어
#### fcntl(2)
``` c
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>

int fcntl(int fildes, int cmd, /*arg*/...);

// fildes: 파일 기술자
// cmd: 명령
// arg: cmd에 따라 필요시 지정하는 인자들
```

* 파일 기술자가 가리키느 ㄴ파일에 cmd로 지정한 명령을 수행한다
	* 이때 cmd의 종류에 따라 인자를 지정해야 할 수도 있다
	* 인자는 <fcntl.h>파일에 정의 되어있다 (ex. F_GETFL - 상태 플래그 정보 읽기, F_SETFL - 상태 플래그 정보 설정 등)

### 파일 삭제
#### unlink(2)
``` c
#include <unistd.h>

int unlink(const char *path);

// path: 삭제할 파일의 경로
```
* path에 지정한 파일의 inode에서 링크 수를 감소시킨다
* 링크 수가 0이 되면 path에 지정한 파일이 삭제된다

* unlink함수를 사용하려면 파일 해당 프로세스는 파일이 위치한 디렉토리에 쓰기 권한이 있어야한다
* unlink함수는 파일 뿐 아니라 디렉토리도 삭제 가능 (디렉토리가 비어있지 않아도 삭제 가능)

#### remove(3)
``` c
#include <stdio.h>

int remove(const char *path);

// path: 경로
```
* unlink 함수와 같다
* 하지만 디렉토리 삭제시 삭제하려는 디렉토리가 비어있지 않으면 삭제 불가


### 파일과 디스크 동기화 함수
#### fsync(3)
``` c
#include <unistd.h>

int fsync(int fildes);

// fildes: 파일 기술자
```
* 메모리에 위치학 있는 파일의 내용을 디스크로 보내 메모리와 디스크의 내용을 동기화한다
* 메모리의 내용이 디스크로 모두 기록되기 전에는 리턴하지 않음